| 首字母 | 指代         | 概念                                                         |
| ------ | ------------ | ------------------------------------------------------------ |
| S      | 单一功能原则 | 认为[对象](https://zh.wikipedia.org/wiki/对象_(计算机科学))应该仅具有一种单一功能的概念。 |
| O      | 开闭原则     | 认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。 |
| L      | 里式替换原则 | 认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。 |
| I      | 接口隔离原则 | 认为“多个特定客户端接口要好于一个宽泛用途的接口"的概念。     |
| D      | 依赖反转原则 | 认为一个方法应该遵从“依赖于抽象而不是一个实例”的概念.依赖注入是该原则的一种实现方式。 |

### 三大特性是：封装,继承,多态  

**所谓封装**，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

**所谓继承** 是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

**所谓多态 **就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。


### 五大基本原则 

**单一职责原则SRP(Single Responsibility Principle)**
是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

**开放封闭原则OCP(Open－Close Principle) **
一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，
那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

**替换原则(the Liskov Substitution Principle LSP) **
子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，
也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

**依赖原则(the Dependency Inversion Principle DIP)** 

具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，
这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到
了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。

**接口分离原则(the Interface Segregation Principle ISP) **
模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来



[快速理解-设计模式六大原则](https://www.jianshu.com/p/807bc228dbc2)

**1、单一职责原则（Single Responsibility Principle，简称SRP ）**

- **核心思想：**应该有且仅有一个原因引起类的变更
- **问题描述：**假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。
- **好处：**类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。
- **需注意：**单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。

------

**2、里氏替换原则（Liskov Substitution Principle,简称LSP）**

- **核心思想：**在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。
- **通俗来讲：**只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。
- **好处：**增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。
- **需注意：**如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。

------

**3、依赖倒置原则（Dependence Inversion Principle,简称DIP）**

- **核心思想**：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；
- **说明**：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。
- **通俗来讲：**依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。
- **问题描述：**类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
- **解决方案：**将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。
- **好处**：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。

------

**4、接口隔离原则（Interface Segregation Principle,简称ISP）**

- **核心思想**：类间的依赖关系应该建立在最小的接口上
- **通俗来讲：**建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
- **问题描述：**类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
- **需注意：**
- **接口尽量小，但是要有限度**。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度
- **提高内聚，减少对外交互**。使接口用最少的方法去完成最多的事情
- **为依赖接口的类定制服务**。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。

------

**5、迪米特法则（Law of Demeter,简称LoD）**

- **核心思想：**类间解耦。
- **通俗来讲：** 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。

------

**6、开放封闭原则（Open Close Principle,简称OCP）**

- **核心思想：**尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
- **通俗来讲：** 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。

------

**一句话概括:**

单一职责原则告诉我们实现类要职责单一；

里氏替换原则告诉我们不要破坏继承体系；

依赖倒置原则告诉我们要面向接口编程；

接口隔离原则告诉我们在设计接口的时候要精简单一；

迪米特法则告诉我们要降低耦合。

而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。

------

组件如何分层

- 底层可以是与业务无关的基础组件, 比如网络和存储等
- 中间层一般是通用的业务组件 , 比如账号, 埋点, 支付, 购物车
- 最上层是迭代业务组件, 更新频率最高

------

好的架构是什么样的?

- 组件化是解决项目大, 人员多的一种很好的手段.
- 协议式和中间者两种架构设计方案
  - 协议式架构设计主要采用的是协议式编程思路: 
  - 中间者统一管理的方式, 来控制 APP 的整个生命周期中组件间的调用关系.

[极客时间 戴铭 项目大了人员多了，架构怎么设计更合理？](https://time.geekbang.org/column/article/86522)

