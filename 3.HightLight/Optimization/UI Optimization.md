### 调试、优化

#### 1.圆角

[圆角](https://github.com/bestswifter/blog/blob/master/articles/ios-rounded-corner.md)

##### 为 UIView 添加圆角

- 为普通的视图直接设置 `cornerRadius` 属性即可
- 我们利用 Core Graphics 自己画出了一个圆角矩形。除了一些必要的代码外，最核心的就是 `CGContextAddArcToPoint `函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形

##### 为 UIImageView 添加圆角

为 `UIImageView` 添加圆角更为常用。它的实现思路是直接截取图片,圆角路径直接用贝塞尔曲线绘制

[UIKit性能调优实战讲解 ](https://bestswifter.com/uikitxing-neng-diao-you-shi-zhan-jiang-jie/)

#### 2.图层混合

首先我们要明白像素的概念，屏幕上每一个点都是一个像素，像素有R、G、B三种颜色构成(有时候还带有alpha值)。如果某一块区域上覆盖了多个layer,最后的显示效果受到这些layer的共同影响。举个例子，上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blending)需要消耗一定的GPU资源。

- `UIView`的`opaque`属性默认值就是`true`，
-  图片也不能含有alpha通道
- 比`opaque`属性更重要的是`backgroundColor`属性，如果不设置这个属性，控件依然被认为是透明的

#### 3.光栅化

光栅化是将一个 layer 预先渲染成位图(bitmap)，然后加入缓存中。

1. 上下微小幅度滑动时，一直是绿色
2. 上下较大幅度滑动，新出现的label一开始是红色，随后变成绿色
3. 如果静止一秒钟，刚开始滑动时会变红。

这是因为layer进行光栅化后渲染成位图放在缓存中。当屏幕出现滑动时，我们直接从缓存中读取而不必渲染，所以会看到绿色。当新的label出现时，缓存中没有个这个label的位图，所以会变成红色。

第三点比较关键，缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。这就是为什么停留一会儿再滑动就会看到红色。

光栅化会导致离屏渲染

#### 4.颜色格式

每个像素有R、G、B和alpha四个值，每个值占用1字节，因此每个像素占用4字节的内存空间。

一张1920*1080的照片(iPhone6 Plus的分辨率)一共有2,073,600个像素，因此占用了超过8Mb的内存。

#### 5.图片大小

图片的缩放需要占用时间，因此我们要尽可能保证无论是本地图片还是从网络或取得图片的大小，都与其frame保持一致。

#### 6.离屏渲染

1. 重写drawRect方法
2. 有mask或者是阴影(layer.masksToBounds, layer.shadow*)，模糊效果也是一种mask
3. layer.shouldRasterize = true

前两者会自动触发离屏渲染，第三种方法是手动开启离屏渲染。

### 优化总结

#### 1. 避免图层混合

1. 确保控件的`opaque`属性设置为`true`，确保`backgroundColor`和父视图颜色一致且不透明
2. 如无特殊需要，不要设置低于1的`alpha`值
3. 确保`UIImage`没有alpha通道

#### 2. 避免临时转换

1. 确保图片大小和`frame`一致，不要在滑动时缩放图片
2. 确保图片颜色格式被GPU支持，避免劳烦CPU转换

#### 3. 慎用离屏渲染

1. 绝大多数时候离屏渲染会影响性能
2. 重写`drawRect`方法，设置圆角、阴影、模糊效果，光栅化都会导致离屏渲染
3. 设置阴影效果是加上阴影路径
4. 滑动时若需要圆角效果，开启光栅化

# iOS性能优化——图片加载和处理



#### 什么是解码？

以UIImageView为例。当其显示在屏幕上时，需要UIImage作为数据源。
UIImage持有的数据是未解码的压缩数据，能节省较多的内存和加快存储。
当UIImage被赋值给UIImage时（例如`imageView.image = image;`），图像数据会被解码，变成RGB的颜色数据。
解码是一个计算量较大的任务，且需要CPU来执行；并且解码出来的图片体积与图片的宽高有关系，而与图片原来的体积无关。
其体积大小可简单描述为：宽 * 高 * 每个像素点的大小 = width * height * 4bytes。

#### 优化1：降采样

在滑动显示的过程中，图片显示的宽高远比真实图片要小，我们可以采用加载缩略图的方式减少图片的占用内存。

#### 优化2：异步处理

**Prefetching**（预处理）和
**Background decoding/downsampling**（子线程解码和降采样）
综合起来，可以**在Prefetching的时候把降采样放到子线程进行处理**，因为降采样过程就包括解码操作。
Prefetching回调中，把降采样的操作放到同步队列serialQueue中，处理完毕之后抛给主线程进行update操作。