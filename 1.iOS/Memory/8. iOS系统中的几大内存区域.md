[iOS系统中的几大内存区域](https://www.jianshu.com/p/de793d58049f)

[iOS程序中的内存分配 栈区堆区全局区](https://www.jianshu.com/p/f3c1b920e8eb)

[iOS-阿里P6一面](https://mp.weixin.qq.com/s?__biz=MzUyNDM5ODI3OQ==&mid=2247483744&idx=1&sn=eb85b8e52612f5f413504856626c0df3&chksm=fa2cbac8cd5b33de463a12c1f188fc37f8d704898f6905fe210e43dbb0695281a8c855db8db2&scene=0&key=4f44f0a7d9d023745e10fd7e19ce672012c352f901a4282fa6bdac76408f87fb7d1184d9e0a3812196ca677c1aa45a6534761c482162516330111173fccb70a428cdbc6ae85d19f840b46a78f0436e46&ascene=0&uin=MTM1NjM2MjE2MA%3D%3D&devicetype=iMac)

[iOS面试题：阿里-P6一面](https://www.jianshu.com/p/de1418dc031a)



## iOS 内存分区

### 内存分区

#### 1. 栈区

- 存放本地变量, 内部临时变量, 函数实参，由编译器自动分配并释放.
- 系统数据结构, 计算机在底层对栈提供支持, 分配专门的寄存器存放栈的地址 ,压栈出栈有专门的指令执行, 决定了栈的效率比较高
- 优点快速高效, 缺点是有限制, 数据不灵活.(先进后出)

###### 栈空间

- 静态分配
  - 编译器完成, 比如自动变量(局部变量)的分配,  
- 动态分配
  - 由 alloca 函数完成, 无需释放, 为可移植的程序起见, 栈的动态分配操作不被鼓励的.



#### 2. 堆区

- 堆是用于存放除了栈里的东西之外所有其他东西的内存区域, 释放工作由自己控制, 程序结束时, 系统会回收
- 虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。
- 优点是灵活方便，数据适应面广泛，但是效率有一定降低

###### 堆空间

- 分配总是动态的



#### 3. 全局区(静态区)

###### 	data 

- 初始化的全局变量和静态变量存放

###### 	bss

- 未初始化的全局变量和静态变量

程序结束后由系统释放。

#### 4. 文字常量区

存放常量字符串，程序结束后由系统释放

#### 5. 程序代码区

存放函数的二进制代码



### 申请后的系统响应

 #### 1. 栈

   每一个函数在执行的时候都会向操作系统索要资源,  栈区就是函数运行时的内存, 栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。

   > 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

#### 2. 堆

   - 首先应该知道操作系统有一个记录空闲内存地址的链表。
   - 当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。
   - 由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中

### 申请后大小的限制

#### 1. 栈

- 栈是向低地址扩展的数据结构，是一块连续的内存的区域。

  - 栈顶的地址和栈的最大容量是系统预先规定好的

    - 如果申请的空间超过栈的剩余空间时，将提示overflow。

因此，能从栈获得的空间较小。

#### 2. 堆

- 堆是向高地址扩展的数据结构，是不连续的内存区域
  - 这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。
    - 堆的大小受限于计算机系统中有效的虚拟内存。

因此，堆获得的空间比较灵活，也比较大。



栈：由系统自动分配，速度较快，不会产生内存碎片
堆：是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便









