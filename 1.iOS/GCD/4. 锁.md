## 互斥锁

包括NSLock、NSConditionLock、@synchronized.

### NSLock

### NSConditionLock

### NSRecrusiveLock

> 使⽤递归锁，同⼀个线程多次获得同⼀个锁，也不会产⽣死锁，只要最后获得的次数和释放的次数⼀致，就会释放锁。

### synchronized

```objc
@synchronized (objct) { 
	//  想要执行的代码
}
```

运⾏这⼀段代码时，运⾏时系统就创建排斥的执⾏该段代码的锁。

@synchronized(obj) 指令使⽤的 obj 为该锁的唯⼀标识，只有当标识相同时，才为满⾜互斥， 如果线程 2 中的@synchronized( obj )改为 @synchronized( self)，那么线程 2 就不会被阻塞.

## ⾃旋锁

加了⾃旋锁，当新线程当访问加锁的代码时，如果发现该段代码已经加锁，就会⼀直的等待这段代码执⾏完毕，解锁。相当于⼀直尝试执⾏这段代码，很耗性能。

## atomic和nonatomic

- noatomic: ⾮原⼦属性，同时可被多个线程读写，线程不安全，效率⾼ 

- atomic：原⼦性，线程安全，同时只能被⼀个线程访问。

  > 被**atomic**修饰的属性，会⾃动的在**set**⽅法中调⽤@**synchronized**（self）。所以效率很低，因为其实@**synchronized**会将他修饰的代码块加⼊到⼀个队列中，⽽同⼀时间，线程只能执⾏队列中的⼀个代码块，所以效率很低。

[线程同步方案](https://juejin.im/post/5cf72a42e51d454f71439c8c#heading-18)

##死锁

#### 死锁问题产生

一般来说，要出现死锁问题需要满足以下条件：

1. 互斥条件：一个资源每次只能被一个线程使用。

2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。

4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

只要破坏死锁 4 个必要条件之一中的任何一个，死锁问题就能被解决。

#### 死锁问题解决

死锁是由四个必要条件导致的，所以一般来说，只要破坏这四个必要条件中的一个条件，死锁情况就应该不会发生。

1. 如果想要打破互斥条件，我们需要允许进程同时访问某些资源，这种方法受制于实际场景，不太容易实现条件；
2. 打破不可抢占条件，这样需要允许进程强行从占有者那里夺取某些资源，或者简单一点理解，占有资源的进程不能再申请占有其他资源，必须释放手上的资源之后才能发起申请，这个其实也很难找到适用场景；
3. 进程在运行前申请得到所有的资源，否则该进程不能进入准备执行状态。这个方法看似有点用处，但是它的缺点是可能导致资源利用率和进程并发性降低；
4. 避免出现资源申请环路，即对资源事先分类编号，按号分配。这种方式可以有效提高资源的利用率和系统吞吐量，但是增加了系统开销，增大了进程对资源的占用时间。

[ibm 线程死锁](https://www.ibm.com/developerworks/cn/java/j-lo-deadlock/index.html)

